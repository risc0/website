# FAQ

-------------------------------
## Contents
* [ZKP System](#zkp-system)
* [Cryptography](#cryptography)
* [Code Project Help](#code-project-help)
* [Guest/Host Interactions](#guest--host-interactions)
* [Data Processing & Performance](#data-processing--performance)

-------------------------------


## ZKP System
<details closed>
<summary>Q:
What is a zero-knowledge proof?
</summary>
<br/>
A:
To simplify slightly, zero-knowledge proofs are a protocol between a 'prover' and a 'verifier'.  With this protocol, the prover can run an agreed-upon function F, passing it secret input and generating both a public output and a 'receipt' of F’s correct execution.  The prover can send this receipt to the verifier, who can then check it, and presuming it checks correctly, the verifier can be very sure that prover ran the function correctly and that it produced a specific output.
</details>
 <br/>

<details closed>
<summary>
Q: How did you make your RISC-V circuit?
</summary>
 <br/>

A: The RISC-V circuit is found in step.cpp.inc and is generated by the make-circuit program. It consists of:
* Code to emulate RISC-V, including deciphering internal state and constructing the execution trace.
* Code to evaluate the constraint polynomials that check the execution trace.
* Auxiliary data to support structures such as ‘taps’.

Because the data structures supporting all three of these need to match very carefully, we created a ‘circuit compiler’ program that generates code for all three of these systems.
</details>
<br/>
<details closed>
<summary>
Q:
What exactly is the method ID and how do I know it will change if the program ASM is altered?
</summary>
 <br/>
 A:
The method ID is the Merkle root for the ‘code’ columns of the proof system. If the ASM changes, then the Merkle root is guaranteed to change by the properties of Merkle trees and it is cryptographically infeasible to create colliding method IDs.
</details>
<br/>
-------------------------------

## Cryptography

-------------------------------

## Code Project Help


<details closed>
<summary>
Q:
What do I do with the proof receipt once I’ve created it?
</summary>
 <br/>
A:
The receipt can be serialized and sent over the network to the verifier. The verifier does not need to have access to the host code, but they do need:
* The method ID of the program (generated by compiling a binary of the trusted ZKVM program)
* Code that runs the receipt.verify() function

 In our code examples, the proof receipt is generated and verified within the same program, but the most common use case is one in which the verification happens on another system.
</details>
<br/>
<details closed>
<summary>
Q: What types of operations does the ZKVM support in Rust?
</summary>
<br/>
A: Currently the ZKVM does not support std, but any crates that work with no_std should be fine. There are sometimes multiple versions of crates and it is necessary to disable certain features. For more information, see this guide.
</details>
<br/>
-------------------------------

## Guest / Host Interactions
<details closed>
<summary>
Q: If the guest ZKVM lives on the host machine, can’t the host still tamper with the compiled code?
</summary>
<br/>
A: Like other zk-STARKs, RISC Zero’s implementation makes it cryptographically infeasable to generate an invalid receipt:
* If the binary is modified, then the receipt’s method ID will not match the method ID expected.
* If the execution is modified, then the execution trace will be invalid.
* If the output is modified, then the journal’s hash will not match the hash recorded in the receipt.
</details>
<br/>
<details closed>
<summary>
Q:  Why does all information need to be loaded at the start of guest ZKVM execution? How does loading data invalidate the receipt?
</summary>
 <br/> 
A: 
Data is sent from the host to the guest via a memory map, but data shared this way cannot change during execution. The validity of the proof relies on its ability to guarantee that code executed in the prover has not been modified; we can think of adding live data here as a form of tampering that invalidates the proof transcript.
</details>
<br/>
<details closed>
<summary>
Q:
How do I know which computations can be offloaded to the host?
</summary>
<br/> 
A:
Because RISC Zero’s ZKVM guarantees that all code run in the VM can be trusted to behave as expected,  its value depends on the host being treated as potentially fully malicious. This means that any operations outsourced to the host should be verified in the ZKVM.
</details>
<br/>
-------------------------------

## Data Processing & Performance
 <br/>
<details closed>
<summary>
Q:
If I can’t change guest data during execution, I might be constrained by space limitations. What if I want to include a large amount of data in my proof of computation?
</summary>
 <br/>
 
A:
There are workarounds for space limitations if the data is included primarily to ensure that the data’s integrity becomes part of the proof of computation. If the data can be processed externally and just needs to be verifiably unchanged, consider processing data externally and sending a Merkle proof to the guest. If no processing is required, consider generating a SHA of a large dataset.
</details>
 <br/>
 
<details closed>
<summary>
Q:
What is the current recommended size of a program running on the ZKVM?
</summary>
<br/>
A:
Although the theoretical maximum size is 128 MB, we recommend that programs be kept no larger than ~1 MB to run on RISC Zero’s current ZKVM implementation.
</details>
 <br/>
<details closed>
<summary>
Q:
I’d like to speed up the processing done inside the ZKVM. What are my options?
</summary>
 <br/>
A:
For cryptographic operations, it is possible to build ‘accelerator’ circuits such as our implementation of SHA26. Fast cryptography is sufficient to support many ‘DeFi’ applications. For many other applications, it is possible to perform most computation on the host (outside the ZKVM) and then verify the results in the ZKVM.
</details>
 <br/>
